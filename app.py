import streamlit as st
import google.generativeai as genai
import json # Para parsear las respuestas JSON de Gemini
import time # Para pausas cortas si es necesario
import random # Para generar IDs √∫nicos si Gemini no los proporciona consistentemente

# --- Configuraci√≥n Inicial y Carga de API Key ---
GEMINI_AVAILABLE = False
model = None
try:
    # Carga la clave API desde los secretos de Streamlit
    GEMINI_API_KEY = st.secrets["GEMINI_API_KEY"]
    genai.configure(api_key=GEMINI_API_KEY)
    # Inicializa el modelo (ajusta 'gemini-pro' si usas otro o uno m√°s reciente como gemini-1.5-flash)
    model = genai.GenerativeModel('gemini-pro')
    # Verificar que el modelo se inicializ√≥ (podr√≠a fallar con clave inv√°lida)
    # Intenta una llamada corta o verifica alg√∫n atributo si es posible
    # model.generate_content("test", generation_config=genai.types.GenerationConfig(max_output_tokens=5)) # Opcional: llamada de prueba
    GEMINI_AVAILABLE = True
    st.sidebar.success("‚úÖ API de Gemini Conectada")

except (KeyError, AttributeError, Exception) as e:
    st.error(f"""
        ‚ö†Ô∏è **Error al configurar la API de Gemini:**
        - Aseg√∫rate de que tu clave API est√° guardada en los secretos de Streamlit como `GEMINI_API_KEY`.
        - Verifica que la clave API sea v√°lida y tenga permisos.
        - Error Detallado: `{e}`
        **La funcionalidad de IA est√° deshabilitada.** Se usar√°n datos de respaldo limitados o la app podr√≠a no funcionar.
        """)
    GEMINI_AVAILABLE = False

# --- Funciones Reales de Gemini ---

def parse_gemini_json_response(response_text):
    """Intenta parsear JSON de la respuesta de Gemini, limpiando posibles decoradores."""
    try:
        # Gemini a veces envuelve el JSON en ```json ... ```
        if response_text.strip().startswith("```json"):
            response_text = response_text.strip()[7:-3].strip() # Quita ```json y ```
        elif response_text.strip().startswith("```"):
             response_text = response_text.strip()[3:-3].strip() # Quita ```
        return json.loads(response_text)
    except json.JSONDecodeError as e:
        st.error(f"‚ùå Error al decodificar JSON de Gemini: {e}")
        st.text_area("Respuesta recibida (no JSON v√°lido):", response_text, height=150)
        return None
    except Exception as e:
        st.error(f"‚ùå Error inesperado al procesar respuesta de Gemini: {e}")
        st.text_area("Respuesta recibida:", response_text, height=150)
        return None


def generar_escenario_gemini(nivel):
    """ Genera 5 escenarios √∫nicos para el nivel dado usando Gemini """
    if not GEMINI_AVAILABLE or not model:
        st.error("API de Gemini no disponible. No se pueden generar escenarios.")
        return [] # Devuelve lista vac√≠a si no hay API

    prompt = f"""
    Eres un experto en √©tica empresarial y dise√±o de simulaciones interactivas.
    Genera EXACTAMENTE 5 escenarios √∫nicos y distintos de crisis empresariales en espa√±ol para un nivel de dificultad '{nivel}'.
    Cada escenario debe incluir:
    - 'id': Un identificador √∫nico y corto (ej: 'p1', 'p2' para principiante; 'i1', 'i2' para intermedio; 'a1', 'a2' para avanzado). Usa el prefijo correcto para el nivel.
    - 'titulo': Un t√≠tulo corto, atractivo y descriptivo en espa√±ol (m√°x 10 palabras).
    - 'trasfondo': Una descripci√≥n detallada (100-150 palabras) de la empresa ficticia, el contexto del mercado, el inicio de la crisis y el rol espec√≠fico que asume el jugador en la simulaci√≥n. Debe estar en espa√±ol.
    - 'estado_inicial': Un diccionario fijo: {{"financiera": 0, "reputacion": 0, "laboral": 0}}.

    Aseg√∫rate de que los escenarios sean apropiados para la dificultad indicada:
    - Principiante: Dilemas √©ticos m√°s directos, menos variables interconectadas.
    - Intermedio: Situaciones con m√°s ambig√ºedad, impacto en m√∫ltiples √°reas, decisiones con pros y contras m√°s balanceados.
    - Avanzado: Escenarios complejos, sist√©micos, con m√∫ltiples partes interesadas (multi-agente), consecuencias a largo plazo y posibles efectos cascada.

    Presenta la respuesta final EXCLUSIVAMENTE como una lista JSON v√°lida de estos 5 diccionarios. No incluyas ning√∫n otro texto antes o despu√©s de la lista JSON.
    Ejemplo de formato de un elemento de la lista:
    {{
        "id": "p1",
        "titulo": "El Informe de Gastos Dudoso",
        "trasfondo": "Eres un nuevo empleado en TecnoSoluciones...",
        "estado_inicial": {{"financiera": 0, "reputacion": 0, "laboral": 0}}
    }}
    """
    try:
        with st.spinner(f"üß† Generando escenarios ({nivel}) con Gemini..."):
            response = model.generate_content(prompt)
            # st.text(response.text) # Descomentar para depurar la respuesta cruda
            parsed_response = parse_gemini_json_response(response.text)

            if parsed_response and isinstance(parsed_response, list) and len(parsed_response) == 5:
                 # Validar estructura b√°sica de cada escenario
                 validated_scenarios = []
                 for i, sc in enumerate(parsed_response):
                     if isinstance(sc, dict) and all(k in sc for k in ['id', 'titulo', 'trasfondo', 'estado_inicial']):
                         # Asegurar IDs √∫nicos si Gemini falla
                         if 'id' not in sc or not sc['id']:
                              sc['id'] = f"{nivel[0].lower()}{i+1}_{random.randint(1000,9999)}"
                         if not isinstance(sc['estado_inicial'], dict) or not all(k in sc['estado_inicial'] for k in ['financiera', 'reputacion', 'laboral']):
                              sc['estado_inicial'] = {"financiera": 0, "reputacion": 0, "laboral": 0} # Corregir si es necesario
                         validated_scenarios.append(sc)
                     else:
                         st.warning(f"Escenario {i+1} recibido de Gemini no tiene el formato esperado. Omitiendo.")
                 if len(validated_scenarios) == 5:
                     st.success(f"‚úÖ ¬°5 escenarios ({nivel}) generados por Gemini!")
                     return validated_scenarios
                 else:
                      st.error(f"Error: Se esperaban 5 escenarios v√°lidos, pero se obtuvieron {len(validated_scenarios)}. Verifica el prompt y la respuesta de Gemini.")
                      return []

            elif parsed_response:
                 st.error(f"Error: Gemini devolvi√≥ una estructura inesperada (no es una lista de 5 elementos).")
                 return []
            else:
                 # El error ya fue mostrado por parse_gemini_json_response
                 return []

    except Exception as e:
        st.error(f"‚ùå Fall√≥ la llamada a Gemini para generar escenarios: {e}")
        return [] # Devuelve lista vac√≠a en caso de error

def generar_pregunta_y_opciones_gemini(contexto, historial, estado, nivel, numero_pregunta):
    """ Genera la siguiente pregunta y opciones usando Gemini """
    if not GEMINI_AVAILABLE or not model:
        st.error("API de Gemini no disponible.")
        return "Pregunta no disponible", []

    historial_str = json.dumps(historial[-2:], ensure_ascii=False) # Enviar solo las √∫ltimas 2 decisiones para brevedad

    prompt = f"""
    Act√∫a como el director experto de una simulaci√≥n interactiva de crisis empresarial en espa√±ol.
    Nivel de dificultad: {nivel}.
    N√∫mero de pregunta actual: {numero_pregunta} de 10.
    Estado actual de la compa√±√≠a: Financiera={estado['financiera']}, Reputaci√≥n={estado['reputacion']}, Clima Laboral={estado['laboral']}.
    Contexto actual de la crisis: {contexto}
    Decisiones recientes tomadas: {historial_str}

    Basado en TODA esta informaci√≥n, genera la SIGUIENTE pregunta cr√≠tica (1 sola pregunta concisa) que el jugador debe responder para avanzar en la simulaci√≥n. La pregunta debe ser relevante al contexto y estado actual, y presentar un dilema √©tico o estrat√©gico claro.
    Adem√°s, proporciona EXACTAMENTE 4 opciones de respuesta de opci√≥n m√∫ltiple (distintas, plausibles y con implicaciones variadas) para esa pregunta. Prefija cada opci√≥n con 'A) ', 'B) ', 'C) ', 'D) '.

    Presenta la respuesta final EXCLUSIVAMENTE como un objeto JSON v√°lido con las claves 'pregunta' (string) y 'opciones' (una lista de 4 strings).
    Ejemplo de formato:
    {{
        "pregunta": "¬øQu√© acci√≥n priorizas ahora?",
        "opciones": [
            "A) Enfocarse en reparar la reputaci√≥n externamente.",
            "B) Invertir en mejorar la moral interna del equipo.",
            "C) Buscar una soluci√≥n financiera r√°pida aunque arriesgada.",
            "D) Esperar a tener m√°s informaci√≥n antes de actuar."
        ]
    }}
    No incluyas ning√∫n otro texto antes o despu√©s del objeto JSON.
    """
    try:
        with st.spinner(f"üß† Generando pregunta {numero_pregunta} con Gemini..."):
            response = model.generate_content(prompt)
            # st.text(response.text) # Debug
            parsed_response = parse_gemini_json_response(response.text)

            if parsed_response and isinstance(parsed_response, dict) and \
               'pregunta' in parsed_response and 'opciones' in parsed_response and \
               isinstance(parsed_response['opciones'], list) and len(parsed_response['opciones']) == 4:
                return parsed_response['pregunta'], parsed_response['opciones']
            else:
                st.error("Error: Gemini devolvi√≥ una pregunta/opciones en formato inesperado.")
                # Fallback muy b√°sico
                return f"Error al generar pregunta {numero_pregunta}. ¬øContinuar?", ["A) S√≠", "B) No", "C) Intentar de nuevo", "D) Salir"]

    except Exception as e:
        st.error(f"‚ùå Fall√≥ la llamada a Gemini para generar pregunta {numero_pregunta}: {e}")
        return f"Error al generar pregunta {numero_pregunta}. ¬øContinuar?", ["A) S√≠", "B) No", "C) Intentar de nuevo", "D) Salir"]


def evaluar_decision_gemini(contexto, pregunta, opcion_elegida, estado_actual, nivel, numero_pregunta):
    """ Eval√∫a la decisi√≥n, genera an√°lisis/consecuencias y nuevo contexto """
    if not GEMINI_AVAILABLE or not model:
        st.error("API de Gemini no disponible.")
        return "An√°lisis no disponible.", "Consecuencias no disponibles.", contexto, {"financiera": 0, "reputacion": 0, "laboral": 0}

    prompt = f"""
    Eres un analista experto en √©tica y estrategia empresarial evaluando una decisi√≥n en una simulaci√≥n interactiva en espa√±ol.
    Nivel de dificultad: {nivel}.
    N√∫mero de pregunta respondida: {numero_pregunta} de 10.
    Contexto ANTES de la decisi√≥n: {contexto}
    Pregunta realizada al jugador: {pregunta}
    Opci√≥n elegida por el jugador: {opcion_elegida}
    Estado de la compa√±√≠a ANTES de la decisi√≥n: Financiera={estado_actual['financiera']}, Reputaci√≥n={estado_actual['reputacion']}, Clima Laboral={estado_actual['laboral']}.

    Por favor, realiza las siguientes tareas y presenta el resultado EXCLUSIVAMENTE como un √∫nico objeto JSON v√°lido con las cuatro claves especificadas ('analisis', 'consecuencias_texto', 'impacto', 'nuevo_contexto'):

    1.  **'analisis'**: Escribe un an√°lisis conciso (2-3 frases) en espa√±ol explicando las implicaciones √©ticas y/o estrat√©gicas de la decisi√≥n tomada ('{opcion_elegida}'). Considera los pros y contras inmediatos y potenciales a futuro.
    2.  **'consecuencias_texto'**: Describe brevemente (1-2 frases) en espa√±ol los efectos M√ÅS PROBABLES e inmediatos de esta decisi√≥n en la situaci√≥n general de la empresa.
    3.  **'impacto'**: Determina el impacto num√©rico M√ÅS PROBABLE de esta decisi√≥n en el estado de la compa√±√≠a. Proporciona un diccionario JSON con las claves 'financiera', 'reputacion', 'laboral'. Los valores deben ser n√∫meros enteros (positivos, negativos o cero). S√© realista y coherente con el an√°lisis, el nivel de dificultad y el estado actual. Rango t√≠pico por decisi√≥n: -3 a +3. Ejemplo: {{"financiera": -1, "reputacion": 0, "laboral": -1}}. Aseg√∫rate que las claves sean exactamente "financiera", "reputacion", "laboral".
    4.  **'nuevo_contexto'**: Escribe un nuevo p√°rrafo de contexto (50-100 palabras) en espa√±ol que describa c√≥mo ha evolucionado la situaci√≥n de la crisis DESPU√âS de la decisi√≥n tomada y sus consecuencias inmediatas. Este nuevo contexto ser√° la base para la siguiente pregunta. Debe reflejar el impacto num√©rico y el an√°lisis.

    Ejemplo de formato de respuesta JSON:
    {{
        "analisis": "Optar por la opci√≥n A prioriza las ganancias a corto plazo, pero ignora riesgos reputacionales significativos que podr√≠an materializarse m√°s adelante.",
        "consecuencias_texto": "La decisi√≥n genera ingresos inmediatos, pero aumenta la tensi√≥n con el equipo de desarrollo y genera preocupaci√≥n en el departamento legal.",
        "impacto": {{ "financiera": 1, "reputacion": -1, "laboral": -1 }},
        "nuevo_contexto": "Tras la decisi√≥n de lanzar el producto apresuradamente, las ventas iniciales son buenas, aliviando la presi√≥n financiera. Sin embargo, empiezan a surgir informes de clientes sobre el problema de sobrecalentamiento en foros online. El equipo de soporte est√° sobrecargado y la moral interna decae mientras se trabaja en un parche urgente..."
    }}
    No incluyas ning√∫n otro texto antes o despu√©s del objeto JSON.
    """
    try:
        with st.spinner(f"üß† Analizando decisi√≥n {numero_pregunta} con Gemini..."):
            # Aumentar un poco el timeout si las evaluaciones son complejas
            generation_config = genai.types.GenerationConfig(
                # temperature=0.7 # Ajustar creatividad si es necesario
            )
            request_options = {"timeout": 120} # Timeout de 120 segundos

            response = model.generate_content(
                prompt,
                generation_config=generation_config,
                request_options=request_options
                )
            # st.text(response.text) # Debug
            parsed_response = parse_gemini_json_response(response.text)

            if parsed_response and isinstance(parsed_response, dict) and \
               all(k in parsed_response for k in ['analisis', 'consecuencias_texto', 'impacto', 'nuevo_contexto']) and \
               isinstance(parsed_response['impacto'], dict) and \
               all(k in parsed_response['impacto'] for k in ['financiera', 'reputacion', 'laboral']):
                # Validar tipos de impacto
                impacto = parsed_response['impacto']
                impacto_validado = {
                    'financiera': int(impacto.get('financiera', 0)),
                    'reputacion': int(impacto.get('reputacion', 0)),
                    'laboral': int(impacto.get('laboral', 0))
                }
                return parsed_response['analisis'], parsed_response['consecuencias_texto'], parsed_response['nuevo_contexto'], impacto_validado
            else:
                st.error("Error: Gemini devolvi√≥ una evaluaci√≥n en formato inesperado.")
                return "An√°lisis no disponible (error formato).", "Consecuencias no disponibles (error formato).", f"{contexto}\n\n(Error al procesar la √∫ltima decisi√≥n. La situaci√≥n no ha cambiado).", {"financiera": 0, "reputacion": 0, "laboral": 0}

    except Exception as e:
        st.error(f"‚ùå Fall√≥ la llamada a Gemini para evaluar decisi√≥n {numero_pregunta}: {e}")
        return "An√°lisis no disponible (error API).", "Consecuencias no disponibles (error API).", f"{contexto}\n\n(Error al procesar la √∫ltima decisi√≥n. La situaci√≥n no ha cambiado).", {"financiera": 0, "reputacion": 0, "laboral": 0}


# --- L√≥gica de la Aplicaci√≥n Streamlit (SIN CAMBIOS SIGNIFICATIVOS) ---
# Mantener la l√≥gica de inicializaci√≥n, p√°ginas, manejo de estado, etc.,
# exactamente como en la versi√≥n anterior, ya que ahora llamar√° a las
# funciones _gemini en lugar de las _mock.

# --- Inicializaci√≥n del estado de sesi√≥n si no existe ---
def inicializar_estado():
    # ... (Exactamente la misma funci√≥n inicializar_estado que antes) ...
    if 'pagina_actual' not in st.session_state:
        st.session_state.pagina_actual = 'inicio' # 'inicio', 'simulacion', 'resultado'
    if 'nivel_dificultad' not in st.session_state:
        st.session_state.nivel_dificultad = "Principiante"
    # Usar un cach√© simple para escenarios por nivel para evitar llamadas repetidas
    if 'cache_escenarios' not in st.session_state:
        st.session_state.cache_escenarios = {} # { 'Principiante': [], 'Intermedio': [], 'Avanzado': [] }
    if 'escenario_seleccionado_id' not in st.session_state:
        st.session_state.escenario_seleccionado_id = None
    if 'datos_escenario' not in st.session_state:
        st.session_state.datos_escenario = None # Contendr√° t√≠tulo, trasfondo, etc.
    if 'estado_simulacion' not in st.session_state:
        st.session_state.estado_simulacion = {"financiera": 0, "reputacion": 0, "laboral": 0}
    if 'estado_anterior' not in st.session_state: # Para calcular deltas
        st.session_state.estado_anterior = {"financiera": 0, "reputacion": 0, "laboral": 0}
    if 'numero_pregunta' not in st.session_state:
        st.session_state.numero_pregunta = 0
    if 'contexto_actual' not in st.session_state:
        st.session_state.contexto_actual = ""
    if 'pregunta_actual' not in st.session_state:
        st.session_state.pregunta_actual = ""
    if 'opciones_actuales' not in st.session_state:
        st.session_state.opciones_actuales = []
    if 'historial_decisiones' not in st.session_state:
        st.session_state.historial_decisiones = []
    if 'ultimo_analisis' not in st.session_state:
        st.session_state.ultimo_analisis = ""
    if 'ultimas_consecuencias' not in st.session_state:
        st.session_state.ultimas_consecuencias = ""
    if 'juego_terminado' not in st.session_state:
        st.session_state.juego_terminado = False
    if 'razon_fin' not in st.session_state:
        st.session_state.razon_fin = ""
    if 'puntaje_final' not in st.session_state:
        st.session_state.puntaje_final = 0


inicializar_estado()

# --- Barra Lateral de Navegaci√≥n ---
st.sidebar.title("Navegaci√≥n")
st.sidebar.page_link("app.py", label="Inicio / Simulaci√≥n")
st.sidebar.page_link("pages/acerca_de.py", label="Acerca de")
st.sidebar.page_link("pages/contacto.py", label="Contacto")

# Mostrar estado de la API en la barra lateral
# (Ya se muestra √©xito o error al inicio)

# --- L√≥gica de P√°ginas ---

# P√°gina de Inicio
if st.session_state.pagina_actual == 'inicio':
    st.title("üöÄ Simulador de Crisis Empresariales")
    st.markdown("Bienvenido/a. Selecciona un nivel y un escenario para comenzar a tomar decisiones cr√≠ticas.")

    nivel = st.selectbox("Selecciona el Nivel de Dificultad:",
                         ["Principiante", "Intermedio", "Avanzado"],
                         index=["Principiante", "Intermedio", "Avanzado"].index(st.session_state.nivel_dificultad),
                         key="nivel_selector")

    # Si cambia el nivel, intentar cargar escenarios desde cach√© o generar nuevos
    if nivel != st.session_state.nivel_dificultad:
        st.session_state.nivel_dificultad = nivel
        st.session_state.escenario_seleccionado_id = None # Resetear selecci√≥n
        # Forzar la recarga/regeneraci√≥n en el siguiente paso
        st.rerun()

    # Cargar/generar escenarios si no est√°n en cach√© para el nivel actual
    if nivel not in st.session_state.cache_escenarios or not st.session_state.cache_escenarios[nivel]:
         if GEMINI_AVAILABLE:
             st.session_state.cache_escenarios[nivel] = generar_escenario_gemini(nivel)
         else:
             st.session_state.cache_escenarios[nivel] = [] # Vac√≠o si no hay API

         # Si la generaci√≥n fall√≥ o no hay API, mostrar mensaje
         if not st.session_state.cache_escenarios[nivel] and GEMINI_AVAILABLE:
              st.error(f"No se pudieron generar escenarios para el nivel {nivel}. Intenta recargar la p√°gina o revisa la conexi√≥n/clave API.")
         elif not GEMINI_AVAILABLE:
              st.warning(f"API de Gemini no disponible. No se pueden cargar escenarios para el nivel {nivel}.")


    # Obtener escenarios disponibles del cach√©
    escenarios_disponibles = st.session_state.cache_escenarios.get(nivel, [])

    if escenarios_disponibles:
        opciones_escenario = {esc['id']: esc['titulo'] for esc in escenarios_disponibles}
        # Asegurarse que el ID seleccionado previamente sigue siendo v√°lido
        current_selection_id = st.session_state.get('escenario_seleccionado_id')
        valid_ids = list(opciones_escenario.keys())
        preselected_index = valid_ids.index(current_selection_id) if current_selection_id in valid_ids else 0

        escenario_id = st.selectbox("Selecciona un Escenario:",
                                    options=valid_ids,
                                    format_func=lambda x: opciones_escenario.get(x, "ID Desconocido"),
                                    index=preselected_index,
                                    key="escenario_selector")

        if st.button("Iniciar Simulaci√≥n", key="start_button"):
            st.session_state.escenario_seleccionado_id = escenario_id
            st.session_state.datos_escenario = next((esc for esc in escenarios_disponibles if esc['id'] == escenario_id), None)

            if st.session_state.datos_escenario:
                # Resetear estado para nueva simulaci√≥n
                st.session_state.estado_simulacion = st.session_state.datos_escenario.get('estado_inicial', {"financiera": 0, "reputacion": 0, "laboral": 0}).copy()
                st.session_state.estado_anterior = st.session_state.estado_simulacion.copy()
                st.session_state.numero_pregunta = 0
                st.session_state.contexto_actual = st.session_state.datos_escenario.get('trasfondo', "Contexto inicial no disponible.")
                st.session_state.historial_decisiones = []
                st.session_state.ultimo_analisis = ""
                st.session_state.ultimas_consecuencias = ""
                st.session_state.juego_terminado = False
                st.session_state.razon_fin = ""
                st.session_state.puntaje_final = 0
                st.session_state.pregunta_actual = ""
                st.session_state.opciones_actuales = []


                # Generar la primera pregunta (AHORA llama a la funci√≥n Gemini real)
                pregunta, opciones = generar_pregunta_y_opciones_gemini(
                    st.session_state.contexto_actual,
                    st.session_state.historial_decisiones,
                    st.session_state.estado_simulacion,
                    st.session_state.nivel_dificultad,
                    1 # N√∫mero de pregunta inicial
                )
                if pregunta and opciones:
                    st.session_state.pregunta_actual = pregunta
                    st.session_state.opciones_actuales = opciones
                    st.session_state.numero_pregunta = 1 # Empezamos con la pregunta 1
                    st.session_state.pagina_actual = 'simulacion'
                    st.rerun()
                else:
                    st.error("No se pudo generar la primera pregunta. Intenta de nuevo.")
            else:
                st.error("Error al cargar los datos del escenario seleccionado.")
    else:
        st.warning(f"No hay escenarios disponibles o no se pudieron cargar para el nivel {nivel}.")


# P√°gina de Simulaci√≥n
elif st.session_state.pagina_actual == 'simulacion':
    if not st.session_state.datos_escenario:
        st.error("Error: No se ha cargado ning√∫n escenario. Volviendo al inicio.")
        st.session_state.pagina_actual = 'inicio'
        time.sleep(2)
        st.rerun()

    # Asegurarse de que haya una pregunta cargada, si no, intentar generar la inicial
    elif not st.session_state.pregunta_actual and st.session_state.numero_pregunta == 1:
         st.warning("Recargando primera pregunta...")
         pregunta, opciones = generar_pregunta_y_opciones_gemini(
                    st.session_state.contexto_actual,
                    st.session_state.historial_decisiones,
                    st.session_state.estado_simulacion,
                    st.session_state.nivel_dificultad,
                    1
                )
         if pregunta and opciones:
             st.session_state.pregunta_actual = pregunta
             st.session_state.opciones_actuales = opciones
             st.rerun()
         else:
             st.error("Fallo cr√≠tico al generar la primera pregunta. Regresando al inicio.")
             st.session_state.pagina_actual = 'inicio'
             time.sleep(2)
             st.rerun()

    elif st.session_state.numero_pregunta > 0: # Estado normal de simulaci√≥n
        st.title(f"Simulaci√≥n: {st.session_state.datos_escenario.get('titulo', 'Sin T√≠tulo')}")

        # Mostrar estado actual con deltas
        col1, col2, col3 = st.columns(3)
        delta_fin = st.session_state.estado_simulacion.get('financiera',0) - st.session_state.estado_anterior.get('financiera',0)
        delta_rep = st.session_state.estado_simulacion.get('reputacion',0) - st.session_state.estado_anterior.get('reputacion',0)
        delta_lab = st.session_state.estado_simulacion.get('laboral',0) - st.session_state.estado_anterior.get('laboral',0)

        col1.metric("üí∞ Situaci√≥n Financiera", st.session_state.estado_simulacion.get('financiera',0), delta=f"{delta_fin:+}" if delta_fin else None)
        col2.metric("üìà Reputaci√≥n", st.session_state.estado_simulacion.get('reputacion',0), delta=f"{delta_rep:+}" if delta_rep else None)
        col3.metric("üë• Clima Laboral", st.session_state.estado_simulacion.get('laboral',0), delta=f"{delta_lab:+}" if delta_lab else None)

        # Barra de progreso
        progress_value = min(st.session_state.numero_pregunta / 10, 1.0) # Asegurar que no pase de 1.0
        st.progress(progress_value)
        st.markdown(f"Pregunta {st.session_state.numero_pregunta} de 10")
        st.markdown("---")

        # Mostrar an√°lisis anterior si existe
        if st.session_state.ultimo_analisis:
             with st.expander("An√°lisis de tu Decisi√≥n Anterior", expanded=False):
                 st.subheader("An√°lisis:")
                 st.info(st.session_state.ultimo_analisis)
                 st.subheader("Consecuencias:")
                 st.warning(st.session_state.ultimas_consecuencias)

        # Mostrar contexto actual
        st.subheader("Situaci√≥n Actual:")
        st.markdown(st.session_state.contexto_actual)
        st.markdown("---")

        # Mostrar pregunta y opciones
        st.subheader(f"Pregunta {st.session_state.numero_pregunta}:")
        st.markdown(st.session_state.pregunta_actual if st.session_state.pregunta_actual else "Cargando pregunta...")

        if st.session_state.opciones_actuales:
            user_choice = st.radio("Selecciona tu decisi√≥n:",
                                   st.session_state.opciones_actuales,
                                   index=None, # No selecci√≥n por defecto
                                   key=f"q_{st.session_state.numero_pregunta}")
        else:
             st.warning("Cargando opciones...")
             user_choice = None # No mostrar radio si no hay opciones

        if st.button("Confirmar Decisi√≥n", key=f"b_{st.session_state.numero_pregunta}", disabled=(not user_choice)):
            if user_choice:
                # Guardar estado anterior para deltas
                st.session_state.estado_anterior = st.session_state.estado_simulacion.copy()

                # Procesar decisi√≥n
                st.session_state.historial_decisiones.append({"pregunta": st.session_state.pregunta_actual, "respuesta": user_choice, "numero": st.session_state.numero_pregunta})

                # Evaluar decisi√≥n (AHORA llama a la funci√≥n Gemini real)
                analisis, cons_texto, nuevo_contexto, impacto = evaluar_decision_gemini(
                    st.session_state.contexto_actual,
                    st.session_state.pregunta_actual,
                    user_choice,
                    st.session_state.estado_simulacion,
                    st.session_state.nivel_dificultad,
                    st.session_state.numero_pregunta
                )

                # Actualizar estado de la simulaci√≥n (asegurarse que impacto es un dict)
                if isinstance(impacto, dict):
                    st.session_state.estado_simulacion['financiera'] = st.session_state.estado_simulacion.get('financiera',0) + impacto.get('financiera', 0)
                    st.session_state.estado_simulacion['reputacion'] = st.session_state.estado_simulacion.get('reputacion',0) + impacto.get('reputacion', 0)
                    st.session_state.estado_simulacion['laboral'] = st.session_state.estado_simulacion.get('laboral',0) + impacto.get('laboral', 0)
                else:
                     st.error("Error: El impacto recibido de Gemini no es v√°lido. El estado no cambiar√°.")


                st.session_state.contexto_actual = nuevo_contexto if nuevo_contexto else st.session_state.contexto_actual # Mantener contexto si falla la generaci√≥n
                st.session_state.ultimo_analisis = analisis
                st.session_state.ultimas_consecuencias = cons_texto

                # Limpiar pregunta/opciones actuales para forzar recarga o fin
                st.session_state.pregunta_actual = ""
                st.session_state.opciones_actuales = []

                # Verificar condiciones de fin (BANCARROTA_THRESHOLD ajustable)
                BANCARROTA_THRESHOLD = -10
                if st.session_state.numero_pregunta >= 10:
                    st.session_state.juego_terminado = True
                    st.session_state.razon_fin = "Se completaron las 10 preguntas."
                elif st.session_state.estado_simulacion.get('financiera', 0) <= BANCARROTA_THRESHOLD:
                    st.session_state.juego_terminado = True
                    st.session_state.razon_fin = f"¬°Bancarrota! La situaci√≥n financiera cay√≥ a {st.session_state.estado_simulacion.get('financiera', 0)} (Umbral: {BANCARROTA_THRESHOLD})."

                if st.session_state.juego_terminado:
                    # Calcular puntaje final
                    st.session_state.puntaje_final = (
                        st.session_state.estado_simulacion.get('financiera', 0) +
                        st.session_state.estado_simulacion.get('reputacion', 0) +
                        st.session_state.estado_simulacion.get('laboral', 0)
                    )
                    st.session_state.pagina_actual = 'resultado'
                    st.rerun() # Ir a p√°gina de resultados

                else:
                    # Pasar a la siguiente pregunta
                    st.session_state.numero_pregunta += 1
                    pregunta, opciones = generar_pregunta_y_opciones_gemini(
                        st.session_state.contexto_actual,
                        st.session_state.historial_decisiones,
                        st.session_state.estado_simulacion,
                        st.session_state.nivel_dificultad,
                        st.session_state.numero_pregunta
                    )
                    if pregunta and opciones:
                        st.session_state.pregunta_actual = pregunta
                        st.session_state.opciones_actuales = opciones
                    else:
                         st.error(f"No se pudo generar la pregunta {st.session_state.numero_pregunta}. Finalizando simulaci√≥n.")
                         st.session_state.juego_terminado = True
                         st.session_state.razon_fin = f"Error al generar la pregunta {st.session_state.numero_pregunta}."
                         st.session_state.pagina_actual = 'resultado'

                    st.rerun() # Actualizar la interfaz para mostrar nueva pregunta o ir a resultados

            # (No es necesario 'else' aqu√≠ porque el bot√≥n est√° deshabilitado si no hay user_choice)


# P√°gina de Resultados
elif st.session_state.pagina_actual == 'resultado':
    # ... (Exactamente la misma p√°gina de resultados que antes) ...
    st.title("üèÅ Resultados de la Simulaci√≥n")
    st.subheader(f"Escenario: {st.session_state.datos_escenario.get('titulo', 'Desconocido')}")

    st.markdown(f"**Raz√≥n del Fin:** {st.session_state.razon_fin}")
    st.markdown("---")
    st.subheader("Estado Final de la Compa√±√≠a:")

    col1, col2, col3 = st.columns(3)
    col1.metric("üí∞ Situaci√≥n Financiera Final", st.session_state.estado_simulacion.get('financiera',0))
    col2.metric("üìà Reputaci√≥n Final", st.session_state.estado_simulacion.get('reputacion',0))
    col3.metric("üë• Clima Laboral Final", st.session_state.estado_simulacion.get('laboral',0))

    st.markdown("---")
    st.subheader("Puntaje Total:")
    # Calcular puntaje aqu√≠ si no se hizo antes
    if 'puntaje_final' not in st.session_state or st.session_state.puntaje_final == 0:
         st.session_state.puntaje_final = (
                        st.session_state.estado_simulacion.get('financiera', 0) +
                        st.session_state.estado_simulacion.get('reputacion', 0) +
                        st.session_state.estado_simulacion.get('laboral', 0)
                    )

    st.metric("üèÜ Puntaje Final", st.session_state.puntaje_final)
    if st.session_state.puntaje_final > 5:
        st.success("¬°Excelente gesti√≥n de la crisis!")
    elif st.session_state.puntaje_final < -5:
        st.error("La gesti√≥n de la crisis tuvo resultados muy negativos.")
    else:
        st.info("La gesti√≥n de la crisis tuvo un resultado mixto o neutral.")

    # Opcional: Mostrar historial de decisiones
    with st.expander("Ver Historial de Decisiones"):
        for i, decision in enumerate(st.session_state.historial_decisiones):
            st.markdown(f"**P{decision.get('numero', i+1)}:** {decision.get('pregunta','-')}")
            st.caption(f"Respuesta: {decision.get('respuesta','-')}")
            st.markdown("---")


    st.markdown("---")
    if st.button("Volver al Inicio", key="back_to_start"):
        # Resetear estado para permitir nueva partida
        st.session_state.pagina_actual = 'inicio'
        st.session_state.escenario_seleccionado_id = None
        st.session_state.datos_escenario = None
        # Mantener cach√© de escenarios
        # Limpiar estado de simulaci√≥n espec√≠fica
        keys_to_reset = ['estado_simulacion', 'estado_anterior', 'numero_pregunta',
                         'contexto_actual', 'pregunta_actual', 'opciones_actuales',
                         'historial_decisiones', 'ultimo_analisis', 'ultimas_consecuencias',
                         'juego_terminado', 'razon_fin', 'puntaje_final']
        for key in keys_to_reset:
            if key in st.session_state:
                del st.session_state[key]
        inicializar_estado() # Reinicializar valores por defecto
        st.rerun()
